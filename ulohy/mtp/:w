#! /usr/bin/env python3

import socket
from typing import Any, Tuple, Optional, Union, TypeVar
import abc.ABC;
import sys

SERVER_IP = "159.89.4.84"
PORT = 42069


class Error():
    """
    Base class for all errors, which allows additional context to be passed with your error.
    """
    def __init__(self, data: Any = None, msg: str = None) -> None:
        self.__data = data
        self.__msg = msg
    
    def message(self) -> Optional[str]:
        return self.__msg

    def inner(self) -> Optional[Any]:
        return self.__data


# Why not become a little rust-y? ;)
# https://doc.rust-lang.org/std/result/enum.Result.html
class Result:
    """
    Representation of either success or failure.
    """
    OK = TypeVar('OK')
    def __init__(self, ok: Any = None, err: Error = None) -> None:
        self.ok = ok
        self.err = err

    def is_ok(self) -> bool:
        return self.ok is not None

    def is_err(self) -> bool:
        return self.err is not None

    def unwrap(self) -> Union[Any, Error]:
        if self.ok is not None:
            return self.ok
        else:
            return self.err


class ChannelError(Error):
    """
    All the errors that can happen when working with channels.
    """
    SEND = -1
    RECEIVE = -2
    CONNECT = -3
    def __init__(self, msg: str = None) -> None:
        super().__init__(msg=msg)


class ChannelResult(Result):
    def __init__(self, ok: Any = None, err: Error = None) -> None:
        super().__init__(ok=ok, err=err)


class MTPError(Error):
    CNL_SEND = ChannelError.SEND 
    CNL_RECEIVE = ChannelError.RECEIVE 
    CNL_CONNECT = ChannelError.CONNECT
    OTHER = -4
    def __init__(self) -> None:
        super().__init__()


class MTPResult(Result):
    """
    Representation of either succes or failure when working with MTP.
    """
    def __init__(self, ok: Any = None, err: Error = None) -> None:
        super().__init__(ok=ok, err=err)


class MTP:
    """
    A class reponsible for MTP communication
    :param ip - IP Address of the server we want to communicate with
    """
    def __init__(self, nick: str, password: str, ip: str=SERVER_IP, port: int=PORT,  is_nsfw: bool = False) -> None:
        self.ip: str = ip
        self.port: int = port
        self.nick: str = nick
        self.password: str = password
        self.is_nsfw = is_nsfw

    def run(self) -> MTPResult:
        pass


class Channel:
    def __init__(self, ip: str, port: int) -> None:
        self.ip = ip
        self.port = port
        self.connection: Optional[socket.socket]

    def connect(self) -> ChannelResult:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if con := s.connect((self.ip, self.port)):
            self.connection = con
            return ChannelResult(ok=ChannelResult.OK)
        else:
            return ChannelResult(err=ChannelError().CONNECT)

    @classmethod
    def encode_data(cls, data: str) -> Tuple[int, bytes]:
        data_lenght = len(data)
        data = f"{data_lenght}:{data}"
        return (data_lenght, b'{data}')

    @classmethod
    def decode_data(cls, data: bytes) -> Tuple[int, str]:
        decoded = data.decode("utf-8")
        return (len(decoded), decoded)

    def send(self, data: str) -> ChannelResult:
        if self.connection:
            size, encoded_data = self.encode_data(data)
            self.connection.sendall(encoded_data)
            return ChannelResult(ok=size)
        else:
            return ChannelResult(err=ChannelError.SEND)

    def recieve(self, amount: int) -> ChannelResult:
        if self.connection:
            buffer = self.connection.recv(amount)
            size, decoded = self.decode_data(buffer)
            return ChannelResult(ok=(size, decoded))
        else:
            return ChannelResult(err=ChannelError.RECEIVE)


class MainChannel(Channel):
    """
    A class responsible for main channel communication.
    """
    def __init__(self, ip: str, port: int, ) -> None:
        super().__init__(ip, port)


class DataChannel(Channel):
    """
    A class responsible for handling the data channel and it's communication.
    """
    def __init__(self, ip: str, port: int) -> None:
        super().__init__(ip, port)


def main() -> None:
    pass


if __name__ == "main":
    main()


def test_result() -> None:
    print(ChannelResult(err=ChannelError.SEND).unwrap())


def run_module_tests() -> None:
    test_result()


if "--test" in sys.argv:
    run_module_tests()
